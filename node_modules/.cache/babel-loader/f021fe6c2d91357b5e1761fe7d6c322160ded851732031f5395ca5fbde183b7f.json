{"ast":null,"code":"/*\nThis code exports an object named \"localstorage\" that contains three methods to perform operations on data stored in the browser's\nlocal storage.\nEach method returns a Promise that resolves to the desired result if the operation is successful, or rejects with an error message if there\nis a failure.\nThe first method, \"getCostsByMonthAndYear\", retrieves all costs from the local storage and filters them to only include costs from the\nspecified month and year. It returns an array of the filtered costs, reversed in order.\nThe second method, \"getCostsByYear\", retrieves all costs from the local storage and filters them to only include costs from the specified\nyear. It returns an array of the filtered costs, reversed in order.\nThe third method, \"addCost\", adds a new cost to the local storage. The new cost is added to an array of all costs, stored in the local\nstorage under the key \"costs\". The new cost is given a unique id based on its item name and the current timestamp.\n*/\n\nconst utilsnamespace = {};\nutilsnamespace.getCostsByMonthAndYear = async (month, year) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForMonthAndYear = allCosts.filter(cost => {\n        const costDate = new Date(cost.purchaseDate);\n        return costDate.getMonth() === parseInt(month) && costDate.getFullYear() === parseInt(year);\n      });\n      resolve(costsForMonthAndYear.reverse());\n    } catch (error) {\n      reject(`Failed to get costs for the month ${month} and year ${year}: ${error}`);\n    }\n  });\n};\nutilsnamespace.getCostsByYear = async year => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForYear = allCosts.filter(cost => {\n        const costDate = new Date(cost.purchaseDate);\n        return costDate.getFullYear() === parseInt(year);\n      });\n      resolve(costsForYear.reverse());\n    } catch (error) {\n      reject(`Failed to get costs for the year ${year}: ${error}`);\n    }\n  });\n};\nutilsnamespace.addCost = async cost => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      allCosts.push({\n        ...cost,\n        // The id must be uniqe so we used timestamp\n        id: `${cost.item_name}${new Date().getTime()}`,\n        purchaseDate: new Date(cost.purchaseDate)\n      });\n      localStorage.setItem('costs', JSON.stringify(allCosts));\n      resolve();\n    } catch (error) {\n      reject(`Failed to add cost ${cost.item_name}: ${error}`);\n    }\n  });\n};\nexport default utilsnamespace;","map":{"version":3,"names":["utilsnamespace","getCostsByMonthAndYear","month","year","Promise","resolve","reject","allCosts","JSON","parse","localStorage","getItem","costsForMonthAndYear","filter","cost","costDate","Date","purchaseDate","getMonth","parseInt","getFullYear","reverse","error","getCostsByYear","costsForYear","addCost","push","id","item_name","getTime","setItem","stringify"],"sources":["/Users/Aviv/Desktop/fed_final_project/src/localstorage.js"],"sourcesContent":["\n/*\nThis code exports an object named \"localstorage\" that contains three methods to perform operations on data stored in the browser's\nlocal storage.\nEach method returns a Promise that resolves to the desired result if the operation is successful, or rejects with an error message if there\nis a failure.\nThe first method, \"getCostsByMonthAndYear\", retrieves all costs from the local storage and filters them to only include costs from the\nspecified month and year. It returns an array of the filtered costs, reversed in order.\nThe second method, \"getCostsByYear\", retrieves all costs from the local storage and filters them to only include costs from the specified\nyear. It returns an array of the filtered costs, reversed in order.\nThe third method, \"addCost\", adds a new cost to the local storage. The new cost is added to an array of all costs, stored in the local\nstorage under the key \"costs\". The new cost is given a unique id based on its item name and the current timestamp.\n*/\n\nconst utilsnamespace = {};\n\nutilsnamespace.getCostsByMonthAndYear = async (month, year) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForMonthAndYear = allCosts.filter((cost) => {\n        const costDate = new Date(cost.purchaseDate);\n        return (\n          costDate.getMonth() === parseInt(month) &&\n          costDate.getFullYear() === parseInt(year)\n        );\n      });\n      resolve(costsForMonthAndYear.reverse());\n    } catch (error) {\n      reject(\n        `Failed to get costs for the month ${month} and year ${year}: ${error}`\n      );\n    }\n  });\n};\n\nutilsnamespace.getCostsByYear = async (year) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForYear = allCosts.filter((cost) => {\n        const costDate = new Date(cost.purchaseDate);\n\n        return costDate.getFullYear() === parseInt(year);\n      });\n\n      resolve(costsForYear.reverse());\n    } catch (error) {\n      reject(`Failed to get costs for the year ${year}: ${error}`);\n    }\n  });\n};\n\nutilsnamespace.addCost = async (cost) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      allCosts.push({\n        ...cost,\n        // The id must be uniqe so we used timestamp\n        id: `${cost.item_name}${new Date().getTime()}`,\n        purchaseDate: new Date(cost.purchaseDate),\n      });\n      localStorage.setItem('costs', JSON.stringify(allCosts));\n      resolve();\n    } catch (error) {\n      reject(`Failed to add cost ${cost.item_name}: ${error}`);\n    }\n  });\n};\n\nexport default utilsnamespace;\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,cAAc,GAAG,CAAC,CAAC;AAEzBA,cAAc,CAACC,sBAAsB,GAAG,OAAOC,KAAK,EAAEC,IAAI,KAAK;EAC7D,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,IAAI;MACF,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE;MAChE,MAAMC,oBAAoB,GAAGL,QAAQ,CAACM,MAAM,CAAEC,IAAI,IAAK;QACrD,MAAMC,QAAQ,GAAG,IAAIC,IAAI,CAACF,IAAI,CAACG,YAAY,CAAC;QAC5C,OACEF,QAAQ,CAACG,QAAQ,EAAE,KAAKC,QAAQ,CAACjB,KAAK,CAAC,IACvCa,QAAQ,CAACK,WAAW,EAAE,KAAKD,QAAQ,CAAChB,IAAI,CAAC;MAE7C,CAAC,CAAC;MACFE,OAAO,CAACO,oBAAoB,CAACS,OAAO,EAAE,CAAC;IACzC,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdhB,MAAM,CACH,qCAAoCJ,KAAM,aAAYC,IAAK,KAAImB,KAAM,EAAC,CACxE;IACH;EACF,CAAC,CAAC;AACJ,CAAC;AAEDtB,cAAc,CAACuB,cAAc,GAAG,MAAOpB,IAAI,IAAK;EAC9C,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,IAAI;MACF,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE;MAChE,MAAMa,YAAY,GAAGjB,QAAQ,CAACM,MAAM,CAAEC,IAAI,IAAK;QAC7C,MAAMC,QAAQ,GAAG,IAAIC,IAAI,CAACF,IAAI,CAACG,YAAY,CAAC;QAE5C,OAAOF,QAAQ,CAACK,WAAW,EAAE,KAAKD,QAAQ,CAAChB,IAAI,CAAC;MAClD,CAAC,CAAC;MAEFE,OAAO,CAACmB,YAAY,CAACH,OAAO,EAAE,CAAC;IACjC,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdhB,MAAM,CAAE,oCAAmCH,IAAK,KAAImB,KAAM,EAAC,CAAC;IAC9D;EACF,CAAC,CAAC;AACJ,CAAC;AAEDtB,cAAc,CAACyB,OAAO,GAAG,MAAOX,IAAI,IAAK;EACvC,OAAO,IAAIV,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,IAAI;MACF,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE;MAChEJ,QAAQ,CAACmB,IAAI,CAAC;QACZ,GAAGZ,IAAI;QACP;QACAa,EAAE,EAAG,GAAEb,IAAI,CAACc,SAAU,GAAE,IAAIZ,IAAI,EAAE,CAACa,OAAO,EAAG,EAAC;QAC9CZ,YAAY,EAAE,IAAID,IAAI,CAACF,IAAI,CAACG,YAAY;MAC1C,CAAC,CAAC;MACFP,YAAY,CAACoB,OAAO,CAAC,OAAO,EAAEtB,IAAI,CAACuB,SAAS,CAACxB,QAAQ,CAAC,CAAC;MACvDF,OAAO,EAAE;IACX,CAAC,CAAC,OAAOiB,KAAK,EAAE;MACdhB,MAAM,CAAE,sBAAqBQ,IAAI,CAACc,SAAU,KAAIN,KAAM,EAAC,CAAC;IAC1D;EACF,CAAC,CAAC;AACJ,CAAC;AAED,eAAetB,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}