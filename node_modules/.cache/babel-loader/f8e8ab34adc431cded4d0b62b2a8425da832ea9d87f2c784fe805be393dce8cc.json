{"ast":null,"code":"const COSTS = {};\n\n/*\nThis function returns a Promise that resolves once a new cost object is added to the array of cost objects stored in local storage.\nThe function retrieves the array by calling localStorage.getItem('costs'),\npushes the new cost object to the array, and stores the updated array in local storage using localStorage.\nsetItem('costs', JSON.stringify(allCosts)).\nThe new cost object is given a unique id by concatenating the item_name with the current timestamp.\nThe function returns a rejected Promise with an error message if an error occurs while retrieving or adding the cost object.\n*/\n\nCOSTS.addCost = async cost => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      allCosts.push({\n        ...cost,\n        // The id must be uniqe so we used timestamp\n        id: `${cost.item_name}${new Date().getTime()}`,\n        purchaseDate: new Date(cost.purchaseDate)\n      });\n      localStorage.setItem('costs', JSON.stringify(allCosts));\n      resolve();\n    } catch (error) {\n      reject(`Failed to add cost ${cost.item_name}: ${error}`);\n    }\n  });\n};\n\n/* \ngetReportByDate(month, year): This function returns a Promise that resolves to an array of cost objects,\nfiltered by the specified month and year. The cost objects are stored in local storage,\nand the method retrieves them by calling localStorage.getItem('costs').\nThe returned array is filtered by checking if the purchaseDate of each cost object matches the specified month and year.\nThe function returns a rejected Promise with an error message if an error occurs while retrieving or filtering the cost objects.\n\n*/\nexport const deleteExpense = async id => {\n  const costs = await getItem();\n  const updatedExpenses = costs.filter(cost => cost.id !== id);\n  setExpenses(updatedExpenses);\n};\nCOSTS.getReportByDate = async (month, year) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForDate = allCosts.filter(cost => {\n        const costDate = new Date(cost.purchaseDate);\n        return costDate.getMonth() === parseInt(month) && costDate.getFullYear() === parseInt(year);\n      });\n      resolve(costsForDate.reverse());\n    } catch (error) {\n      reject(`Failed to get costs for the month ${month} and year ${year}: ${error}`);\n    }\n  });\n};\nCOSTS.getReportByYear = async year => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForYear = allCosts.filter(cost => {\n        const costDate = new Date(cost.purchaseDate);\n        return costDate.getFullYear() === parseInt(year);\n      });\n      resolve(costsForYear.reverse());\n    } catch (error) {\n      reject(`Failed to get costs for the year ${year}: ${error}`);\n    }\n  });\n};\nexport default COSTS;","map":{"version":3,"names":["COSTS","addCost","cost","Promise","resolve","reject","allCosts","JSON","parse","localStorage","getItem","push","id","item_name","Date","getTime","purchaseDate","setItem","stringify","error","deleteExpense","costs","updatedExpenses","filter","setExpenses","getReportByDate","month","year","costsForDate","costDate","getMonth","parseInt","getFullYear","reverse","getReportByYear","costsForYear"],"sources":["/Users/Aviv/Desktop/fed_final_project/src/localstorage.js"],"sourcesContent":["const COSTS = {};\n\n/*\nThis function returns a Promise that resolves once a new cost object is added to the array of cost objects stored in local storage.\nThe function retrieves the array by calling localStorage.getItem('costs'),\npushes the new cost object to the array, and stores the updated array in local storage using localStorage.\nsetItem('costs', JSON.stringify(allCosts)).\nThe new cost object is given a unique id by concatenating the item_name with the current timestamp.\nThe function returns a rejected Promise with an error message if an error occurs while retrieving or adding the cost object.\n*/ \n\nCOSTS.addCost = async (cost) => {\n    return new Promise((resolve, reject) => {\n      try {\n        const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n        allCosts.push({\n          ...cost,\n          // The id must be uniqe so we used timestamp\n          id: `${cost.item_name}${new Date().getTime()}`,\n          purchaseDate: new Date(cost.purchaseDate),\n        });\n        localStorage.setItem('costs', JSON.stringify(allCosts));\n        resolve();\n      } catch (error) {\n        reject(`Failed to add cost ${cost.item_name}: ${error}`);\n      }\n    });\n  };\n  \n\n   \n\n\n\n\n\n/* \ngetReportByDate(month, year): This function returns a Promise that resolves to an array of cost objects,\nfiltered by the specified month and year. The cost objects are stored in local storage,\nand the method retrieves them by calling localStorage.getItem('costs').\nThe returned array is filtered by checking if the purchaseDate of each cost object matches the specified month and year.\nThe function returns a rejected Promise with an error message if an error occurs while retrieving or filtering the cost objects.\n\n*/ \nexport const deleteExpense = async (id) => {\n    const costs = await getItem();\n    const updatedExpenses = costs.filter((cost) => cost.id !== id);\n    setExpenses(updatedExpenses);\n}; \n\nCOSTS.getReportByDate = async (month, year) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForDate = allCosts.filter((cost) => {\n        const costDate = new Date(cost.purchaseDate);\n        return (\n          costDate.getMonth() === parseInt(month) &&\n          costDate.getFullYear() === parseInt(year)\n        );\n      });\n      resolve(costsForDate.reverse());\n    } catch (error) {\n      reject(\n        `Failed to get costs for the month ${month} and year ${year}: ${error}`\n      );\n    }\n  });\n};\n\n\n\nCOSTS.getReportByYear = async (year) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const allCosts = JSON.parse(localStorage.getItem('costs')) || [];\n      const costsForYear = allCosts.filter((cost) => {\n        const costDate = new Date(cost.purchaseDate);\n\n        return costDate.getFullYear() === parseInt(year);\n      });\n\n      resolve(costsForYear.reverse());\n    } catch (error) {\n      reject(`Failed to get costs for the year ${year}: ${error}`);\n    }\n  });\n};\n\n\n\nexport default COSTS;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}